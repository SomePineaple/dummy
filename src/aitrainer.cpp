//
// Created by nj60 on 11/17/25.
//

#include "nn/training/cpu_trainer.h"

// TODO: Increase generation size to 2000+, then build a rule based bot that just plays everything it gets with some randomness to test against.
// Have everyone do 5 rounds against baseline bot, filter out bottom 75%, then have the rest do 20, filter out 80% of whose remaining and run 50 rounds with top 100 who are left to choose 80 or so parents
// Same number of games as current config, but should go faster with rule bot.

constexpr uint16_t GENERATION_SIZE = 2000;
constexpr int BAD_MOVE_REWARD = -50;
constexpr uint64_t MAX_GAME_LENGTH = 100;
constexpr uint16_t NUM_GENERATIONS = 200;

#if defined(_WIN32)
#include <windows.h>

// TODO: Generated by ChatGPT, I have yet to test this
uint64_t getAvailableMemory() {
    MEMORYSTATUSEX memInfo;
    memInfo.dwLength = sizeof(memInfo);
    if (!GlobalMemoryStatusEx(&memInfo))
        throw std::runtime_error("GlobalMemoryStatusEx failed");
    return static_cast<uint64_t>(memInfo.ullAvailPhys);
}

#elif defined(__APPLE__)
#include <cstdint>
#include <stdexcept>

#include <mach/mach.h>
#include <mach/mach_host.h>
#include <mach/vm_statistics.h>
#include <unistd.h>

// Generated by ChatGPT, I don't have an apple computer and cannot test this
uint64_t getAvailableMemory() {
    mach_port_t hostPort = mach_host_self();
    if (hostPort == MACH_PORT_NULL)
        throw std::runtime_error("mach_host_self() failed");

    vm_size_t pageSize = 0;
    if (host_page_size(hostPort, &pageSize) != KERN_SUCCESS)
        throw std::runtime_error("host_page_size() failed");

    vm_statistics64_data_t vmStat{};
    mach_msg_type_number_t count = HOST_VM_INFO64_COUNT;

    if (host_statistics64(hostPort, HOST_VM_INFO64, reinterpret_cast<host_info64_t>(&vmStat), &count) != KERN_SUCCESS) {
        throw std::runtime_error("host_statistics64() failed");
    }

    uint64_t freePages = vmStat.free_count;
    uint64_t inactivePages = vmStat.inactive_count;
    uint64_t speculativePages = vmStat.speculative_count;

    uint64_t availablePages = freePages + inactivePages + speculativePages;

    return availablePages * static_cast<uint64_t>(pageSize);
}
#else
#include <fstream>
#include <string>
#include <stdexcept>

uint64_t getAvailableMemory() {
    std::ifstream meminfo("/proc/meminfo");
    if (!meminfo)
        throw std::runtime_error("Could not open /proc/meminfo");

    std::string key, unit;
    uint64_t availableMemKb = 0;

    while (meminfo >> key >> availableMemKb >> unit) {
        if (key == "MemAvailable:")
            return availableMemKb * 1024;
    }

    throw std::runtime_error("MemAvailable not found in /proc/meminfo");
}

#endif

int main() {
    uint64_t availableRam = 0;
    try {
        availableRam = getAvailableMemory();
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
        std::cerr << "WARNING: Failed to get available memory, we may use more than the computer has available" << std::endl;
    }

    uint64_t generationSize = GENERATION_SIZE;
    if (availableRam != 0) {
        // We need to run input through the networks to ensure they are fully intitialized
        rummy::nn::card_input_t embedInput;
        embedInput = 0;
        rummy::nn::embedder_t embedder;
        embedder(embedInput);

        rummy::nn::net_input_t actorInput;
        actorInput = 0;
        rummy::nn::actor_t actor;
        actor(actorInput);

        const uint64_t bytesPerInstance = (dlib::count_parameters(embedder) + dlib::count_parameters(actor)) * sizeof(float);

        // leave 500mb safety margin
        generationSize = std::min(generationSize, (availableRam - (500 * 1024 * 1024)) / bytesPerInstance);

        std::cout << "We have " << availableRam << " bytes of ram available, limiting generation size to " << generationSize << std::endl;
    }

    rummy::nn::CpuTrainer trainer(MAX_GAME_LENGTH, generationSize, BAD_MOVE_REWARD, std::thread::hardware_concurrency(), .1, 0.05);
    for (uint16_t i = 0; i < NUM_GENERATIONS; i++) {
        std::cout << "Testing generation " << i << std::endl;
        trainer.test_generation();
        trainer.evolve(generationSize * 0.1, generationSize * 0.1);

        // Save the top 5 networks every 10 generations
        if (!(i % 10)) {
            std::cout << "Saving the top 5 networks to a file..." << std::endl;
            trainer.save_top(5);
            std::cout << "done." << std::endl;
        }
    }
    return 0;
}
